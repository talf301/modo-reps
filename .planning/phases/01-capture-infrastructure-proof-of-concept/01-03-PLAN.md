---
phase: 01-capture-infrastructure-proof-of-concept
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src-tauri/src/capture/handle.rs, src-tauri/src/capture/filter.rs]
autonomous: true
user_setup:
  - service: WinDivert
    why: "Windows packet capture driver required for MTGO traffic interception"
    env_vars:
      - name: WINDIVERT_PATH
        source: "Optional: set if WinDivert binaries are not in application directory"
    dashboard_config:
      - task: "Download WinDivert 2.2.2-A signed binaries"
        location: "https://reqrypt.org/windivert.html"
      - task: "Place WinDivert.dll and WinDivert64.sys in application directory"
        location: "Application binary directory"

must_haves:
  truths:
    - "WinDivert capture starts successfully"
    - "Application closes cleanly after capture"
    - "Filter is validated before capture begins"
  artifacts:
    - path: "src-tauri/src/capture/handle.rs"
      provides: "WinDivert handle management"
      contains: "create_handle"
    - path: "src-tauri/src/capture/filter.rs"
      provides: "WinDivert filter definition"
      contains: "MTGO_FILTER"
  key_links:
    - from: "src-tauri/src/capture/handle.rs"
      to: "windivert::WinDivert"
      via: "typestate builder pattern"
      pattern: "WinDivert::builder\\(\\)"
    - from: "src-tauri/src/capture/filter.rs"
      to: "src-tauri/src/capture/handle.rs"
      via: "filter constant reference"
      pattern: "MTGO_FILTER"
---

<objective>
Create WinDivert handle and filter management module to initialize packet capture with proper filtering for MTGO traffic.

Purpose: Implement core WinDivert integration following RESEARCH.md Pattern 1 (WinDivert Handle Lifecycle with Typestate), avoiding Pitfall 4 (Incorrect WinDivert Filter Syntax).
Output: WinDivert handle creation with filter validation and cleanup management.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-capture-infrastructure-proof-of-concept/01-RESEARCH.md

# Prior Plan 01-01: Tauri project initialized with windivert dependency
# This plan creates WinDivert handle and filter management
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define MTGO traffic filter and create WinDivert handle</name>
  <files>src-tauri/src/capture/filter.rs, src-tauri/src/capture/handle.rs, src-tauri/src/capture/mod.rs</files>
  <action>
Update src-tauri/src/capture/mod.rs:
```rust
pub mod admin;
pub mod handle;
pub mod filter;
```

Create src-tauri/src/capture/filter.rs with MTGO traffic filter:

```rust
/// MTGO traffic filter string
///
/// This filter captures all outbound TCP traffic. Starting with a broad filter
/// allows us to capture actual MTGO traffic and identify specific server IPs/ports
/// during the proof-of-concept phase.
///
/// Per RESEARCH.md Open Question 1, exact MTGO server characteristics are unknown.
/// We will log captured IPs/ports and narrow the filter in future phases based on
/// actual MTGO traffic patterns.
///
/// Filter components:
/// - "outbound": Only capture outbound traffic from local machine
/// - "tcp": Only capture TCP packets (MTGO uses TCP, likely HTTP/HTTPS)
/// - No port restrictions initially - broad capture for discovery
///
/// Future refinement: After discovering MTGO servers, update filter to:
/// "outbound and tcp and (ip.DstAddr == SERVER_IP_1 or ip.DstAddr == SERVER_IP_2)"
pub const MTGO_FILTER: &str = "outbound and tcp";
```

Create src-tauri/src/capture/handle.rs with handle management (from RESEARCH.md Pattern 1):

```rust
#[cfg(target_os = "windows")]
use windivert::{layer::Network, WinDivert, WinDivertFlags};
use crate::capture::filter::MTGO_FILTER;
use crate::common::error::CaptureError;
use std::sync::Arc;

/// Wrapper for WinDivert handle with automatic cleanup
///
/// Uses Arc<WinDivert<Network>> to allow sharing handle between capture loop
/// and control commands without worrying about lifetime issues.
pub struct CaptureHandle {
    inner: Arc<WinDivert<Network>>,
}

impl CaptureHandle {
    /// Create a new WinDivert handle for capturing MTGO traffic
    ///
    /// This function initializes WinDivert with the MTGO traffic filter and
    /// sets up packet sniffing mode (copies packets without dropping them).
    ///
    /// # Returns
    /// Ok(CaptureHandle) if handle created successfully
    /// Err(CaptureError) if initialization fails (e.g., insufficient privileges, driver blocked)
    ///
    /// # Note
    /// Caller must verify administrator privileges before calling this function.
    /// See `capture::admin::is_running_as_admin()`.
    ///
    /// The WinDivert builder validates the filter syntax at creation time,
    /// catching filter syntax errors during development (Pitfall 4).
    #[cfg(target_os = "windows")]
    pub fn new() -> Result<Self, CaptureError> {
        // Basic syntax validation: check for balanced parentheses
        let mut paren_count = 0;
        for ch in MTGO_FILTER.chars() {
            match ch {
                '(' => paren_count += 1,
                ')' => paren_count -= 1,
                _ => {}
            }
        }
        if paren_count != 0 {
            return Err(CaptureError::CaptureLoopError(
                format!("Unbalanced parentheses in filter: {}", MTGO_FILTER)
            ));
        }

        // Build WinDivert handle with typestate pattern
        let handle = WinDivert::builder()
            .layer(Network::Network)  // WINDIVERT_LAYER_NETWORK
            .filter(MTGO_FILTER)      // Apply MTGO traffic filter
            .flags(WinDivertFlags::SNIFF)  // Packet sniffing: copy, don't drop packets
            .build()?;  // This validates filter syntax and creates handle

        Ok(CaptureHandle {
            inner: Arc::new(handle),
        })
    }

    /// Get a reference to the inner WinDivert handle
    ///
    /// This is used by the capture loop to receive packets.
    #[cfg(target_os = "windows")]
    pub fn inner(&self) -> &Arc<WinDivert<Network>> {
        &self.inner
    }

    /// Clone the handle (increment Arc refcount)
    ///
    /// This allows sharing the handle between tasks.
    #[cfg(target_os = "windows")]
    pub fn clone_handle(&self) -> Arc<WinDivert<Network>> {
        Arc::clone(&self.inner)
    }
}

/// Stub implementation for non-Windows targets (development only)
#[cfg(not(target_os = "windows"))]
pub struct CaptureHandle;

#[cfg(not(target_os = "windows"))]
impl CaptureHandle {
    pub fn new() -> Result<Self, CaptureError> {
        Ok(CaptureHandle)
    }
}
```

DO NOT hardcode specific MTGO ports in the filter yet - exact ports are unknown (RESEARCH.md Open Question 1). Start broad and refine based on captured traffic. The WinDivert builder validates the filter at creation time, catching syntax errors.
  </action>
  <verify>grep -E "(MTGO_FILTER|CaptureHandle|WinDivert::builder|WINDIVERT_LAYER_NETWORK|WinDivertFlags::SNIFF)" src-tauri/src/capture/handle.rs src-tauri/src/capture/filter.rs</verify>
  <done>Filter constant defined with TCP outbound capture, WinDivert handle wrapper created with Arc sharing and typestate builder pattern, filter validated during creation</done>
</task>

<task type="auto">
  <name>Task 2: Implement handle cleanup on shutdown</name>
  <files>src-tauri/src/capture/handle.rs</files>
  <action>
Add cleanup functionality to src-tauri/src/capture/handle.rs:

```rust
impl Drop for CaptureHandle {
    /// Ensure WinDivert handle is properly closed when dropped
    ///
    /// The WinDivert<Network> type implements Drop, so closing the Arc
    /// when the last reference is dropped automatically closes the WinDivert handle.
    fn drop(&mut self) {
        #[cfg(target_os = "windows")]
        {
            // The inner Arc<WinDivert<Network>> will automatically close
            // when this CaptureHandle is dropped and the Arc refcount reaches zero.
            // No manual cleanup needed - RAII handles it.
        }
    }
}
```

The RAII (Resource Acquisition Is Initialization) pattern ensures the WinDivert handle is closed automatically when CaptureHandle goes out of scope. No manual close() calls needed.

DO NOT manually call WinDivertClose - rely on Drop implementation. This prevents resource leaks even on panic or early return.
  </action>
  <verify>grep -E "(impl Drop|fn drop)" src-tauri/src/capture/handle.rs</verify>
  <done>Drop implementation ensures automatic handle cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Add filter analysis task for BPF refinement</name>
  <files>src-tauri/src/capture/filter.rs</files>
  <action>
Add filter analysis function to src-tauri/src/capture/filter.rs:

```rust
/// Analyze captured IP addresses and ports for filter refinement
///
/// This function processes captured packet metadata to identify MTGO server
/// characteristics (IP ranges, specific ports) for refining the BPF filter.
///
/// The filter can then be updated from "outbound and tcp" to:
/// "outbound and tcp and (ip.DstAddr == MTGO_IP_1 or ip.DstAddr == MTGO_IP_2)"
///
/// This addresses Success Criterion #5: "BPF filter successfully filters MTGO server traffic,
/// reducing captured packets to < 10MB/hour"
///
/// # Arguments
/// * `captured_ips` - Vec of (ip_address, port) tuples from captured packets
///
/// # Returns
/// Suggested refined filter string, or current filter if insufficient data
#[cfg(target_os = "windows")]
pub fn analyze_and_suggest_refined_filter(captured_ips: Vec<(String, u16)>) -> String {
    if captured_ips.len() < 100 {
        // Not enough data for meaningful analysis
        return MTGO_FILTER.to_string();
    }

    // Count occurrences of each (ip, port) pair
    use std::collections::HashMap;
    let mut ip_port_counts: HashMap<(String, u16), usize> = HashMap::new();

    for (ip, port) in captured_ips {
        *ip_port_counts.entry((ip, port)).or_insert(0) += 1;
    }

    // Identify top IP/port pairs (likely MTGO servers)
    let mut pairs: Vec<_> = ip_port_counts.into_iter().collect();
    pairs.sort_by(|a, b| b.1.cmp(&a.1));

    // Take top 5 most common pairs
    let top_pairs: Vec<_> = pairs.into_iter().take(5).collect();

    if top_pairs.is_empty() {
        return MTGO_FILTER.to_string();
    }

    // Build refined filter: "outbound and tcp and (ip.DstAddr == IP1 or ip.DstAddr == IP2 ...)"
    let ip_conditions: Vec<String> = top_pairs
        .iter()
        .map(|((ip, _port), _count)| format!("ip.DstAddr == {}", ip))
        .collect();

    let refined_filter = format!(
        "outbound and tcp and ({})",
        ip_conditions.join(" or ")
    );

    refined_filter
}

/// Stub for non-Windows targets
#[cfg(not(target_os = "windows"))]
pub fn analyze_and_suggest_refined_filter(_captured_ips: Vec<(String, u16)>) -> String {
    MTGO_FILTER.to_string()
}
```

This function will be called in Plan 05 (capture loop) to collect and analyze captured IP/port information. The refined filter can then be applied in subsequent sessions.

DO NOT automatically update the filter - this function only suggests a refined filter. Manual review is required to ensure we don't filter out legitimate MTGO traffic.
  </action>
  <verify>grep -E "(analyze_and_suggest_refined_filter|MTGO_FILTER)" src-tauri/src/capture/filter.rs</verify>
  <done>Filter analysis function created for BPF refinement based on captured traffic patterns</done>
</task>

</tasks>

<verification>
- MTGO filter defined for outbound TCP traffic
- WinDivert handle creation with typestate builder pattern and filter validation
- SNIFF flag configured (copy, don't drop packets)
- RAII cleanup via Drop trait
- Filter analysis function for BPF refinement created
- Project compiles without errors
</verification>

<success_criteria>
WinDivert handle and filter management module created with MTGO traffic filter, handle creation with typestate pattern, filter validation during creation, automatic cleanup on shutdown, and filter analysis function for BPF refinement.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-03-SUMMARY.md`
</output>

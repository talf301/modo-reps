---
phase: 01-capture-infrastructure-proof-of-concept
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src-tauri/src/capture/handle.rs, src-tauri/src/capture/filter.rs]
autonomous: true
user_setup:
  - service: WinDivert
    why: "Windows packet capture driver required for MTGO traffic interception"
    env_vars:
      - name: WINDIVERT_PATH
        source: "Optional: set if WinDivert binaries are not in application directory"
    dashboard_config:
      - task: "Download WinDivert 2.2.2-A signed binaries"
        location: "https://reqrypt.org/windivert.html"
      - task: "Place WinDivert.dll and WinDivert64.sys in application directory"
        location: "Application binary directory"

must_haves:
  truths:
    - "WinDivert handle can be created with filter for TCP traffic"
    - "Filter compilation catches syntax errors before runtime"
    - "Handle cleanup prevents resource leaks"
  artifacts:
    - path: "src-tauri/src/capture/handle.rs"
      provides: "WinDivert handle management"
      contains: "create_handle"
    - path: "src-tauri/src/capture/filter.rs"
      provides: "WinDivert filter compilation and validation"
      contains: "MTGO_FILTER"
  key_links:
    - from: "src-tauri/src/capture/handle.rs"
      to: "windivert::WinDivert"
      via: "typestate builder pattern"
      pattern: "WinDivert::builder\\(\\)"
    - from: "src-tauri/src/capture/filter.rs"
      to: "windivert_sys::WinDivertHelperCompileFilter"
      via: "filter validation"
      pattern: "WinDivertHelperCompileFilter"
---

<objective>
Create WinDivert handle and filter management module to initialize packet capture with proper filtering for MTGO traffic.

Purpose: Implement core WinDivert integration following RESEARCH.md Pattern 1 (WinDivert Handle Lifecycle with Typestate), avoiding Pitfall 4 (Incorrect WinDivert Filter Syntax).
Output: WinDivert handle creation and filter validation with cleanup management.
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-capture-infrastructure-proof-of-concept/01-RESEARCH.md

# Prior Plan 01-01: Tauri project initialized with windivert dependency
# This plan creates WinDivert handle and filter management
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define MTGO traffic filter</name>
  <files>src-tauri/src/capture/filter.rs</files>
  <action>
Create src-tauri/src/capture/filter.rs with MTGO traffic filter:

```rust
/// MTGO traffic filter string
///
/// This filter captures all outbound TCP traffic. Starting with a broad filter
/// allows us to capture actual MTGO traffic and identify specific server IPs/ports
/// during the proof-of-concept phase.
///
/// Per RESEARCH.md Open Question 1, exact MTGO server characteristics are unknown.
/// We will log captured IPs/ports and narrow the filter in future phases based on
/// actual MTGO traffic patterns.
///
/// Filter components:
/// - "outbound": Only capture outbound traffic from local machine
/// - "tcp": Only capture TCP packets (MTGO uses TCP, likely HTTP/HTTPS)
/// - No port restrictions initially - broad capture for discovery
///
/// Future refinement: After discovering MTGO servers, update filter to:
/// "outbound and tcp and (ip.DstAddr == SERVER_IP_1 or ip.DstAddr == SERVER_IP_2)"
pub const MTGO_FILTER: &str = "outbound and tcp";

/// Validate filter string using WinDivertHelperCompileFilter
///
/// This function catches filter syntax errors during development rather than
/// at runtime (Pitfall 4: Incorrect WinDivert Filter Syntax).
///
/// # Returns
/// Ok(()) if filter compiles successfully
/// Err(String) with compilation error message if filter is invalid
#[cfg(target_os = "windows")]
pub fn validate_filter(filter: &str) -> Result<(), String> {
    use windivert_sys::WinDivertLayer;
    use std::ptr;

    let layer = WinDivertLayer::WINDIVERT_LAYER_NETWORK;

    // Note: WinDivertHelperCompileFilter returns a compiled filter object.
    // For validation purposes in Rust, we can use the windivert crate's
    // compile-time filter checking or test filter at runtime.
    // This is a placeholder for runtime filter testing.
    //
    // Alternative: Create a dummy WinDivert handle with the filter to test it.
    // See Task 2 for the actual handle creation which validates the filter.

    // For now, basic syntax validation: check for balanced parentheses
    let mut paren_count = 0;
    for ch in filter.chars() {
        match ch {
            '(' => paren_count += 1,
            ')' => paren_count -= 1,
            _ => {}
        }
    }
    if paren_count != 0 {
        return Err(format!("Unbalanced parentheses in filter: {}", filter));
    }

    Ok(())
}

/// Stub for non-Windows targets
#[cfg(not(target_os = "windows"))]
pub fn validate_filter(_filter: &str) -> Result<(), String> {
    Ok(())
}
```

DO NOT hardcode specific MTGO ports in the filter yet - exact ports are unknown (RESEARCH.md Open Question 1). Start broad and refine based on captured traffic.
  </action>
  <verify>grep -E "(MTGO_FILTER|validate_filter)" src-tauri/src/capture/filter.rs</verify>
  <done>Filter constant defined with TCP outbound capture, validation function created</done>
</task>

<task type="auto">
  <name>Task 2: Create WinDivert handle management</name>
  <files>src-tauri/src/capture/handle.rs</files>
  <action>
Update src-tauri/src/capture/mod.rs:
```rust
pub mod admin;
pub mod handle;
pub mod filter;
```

Create src-tauri/src/capture/handle.rs with handle management (from RESEARCH.md Pattern 1):

```rust
#[cfg(target_os = "windows")]
use windivert::{layer::Network, WinDivert, WinDivertFlags};
use crate::capture::filter::MTGO_FILTER;
use crate::common::error::CaptureError;
use std::sync::Arc;

/// Wrapper for WinDivert handle with automatic cleanup
///
/// Uses Arc<WinDivert<Network>> to allow sharing handle between capture loop
/// and control commands without worrying about lifetime issues.
pub struct CaptureHandle {
    inner: Arc<WinDivert<Network>>,
}

impl CaptureHandle {
    /// Create a new WinDivert handle for capturing MTGO traffic
    ///
    /// This function initializes WinDivert with the MTGO traffic filter and
    /// sets up packet sniffing mode (copies packets without dropping them).
    ///
    /// # Returns
    /// Ok(CaptureHandle) if handle created successfully
    /// Err(CaptureError) if initialization fails (e.g., insufficient privileges, driver blocked)
    ///
    /// # Note
    /// Caller must verify administrator privileges before calling this function.
    /// See `capture::admin::is_running_as_admin()`.
    #[cfg(target_os = "windows")]
    pub fn new() -> Result<Self, CaptureError> {
        // Build WinDivert handle with typestate pattern
        let handle = WinDivert::builder()
            .layer(Network::Network)  // WINDIVERT_LAYER_NETWORK
            .filter(MTGO_FILTER)      // Apply MTGO traffic filter
            .flags(WinivertFlags::SNIFF)  // Packet sniffing: copy, don't drop packets
            .build()?;

        Ok(CaptureHandle {
            inner: Arc::new(handle),
        })
    }

    /// Get a reference to the inner WinDivert handle
    ///
    /// This is used by the capture loop to receive packets.
    #[cfg(target_os = "windows")]
    pub fn inner(&self) -> &Arc<WinDivert<Network>> {
        &self.inner
    }

    /// Clone the handle (increment Arc refcount)
    ///
    /// This allows sharing the handle between tasks.
    #[cfg(target_os = "windows")]
    pub fn clone_handle(&self) -> Arc<WinDivert<Network>> {
        Arc::clone(&self.inner)
    }
}

/// Stub implementation for non-Windows targets (development only)
#[cfg(not(target_os = "windows"))]
pub struct CaptureHandle;

#[cfg(not(target_os = "windows"))]
impl CaptureHandle {
    pub fn new() -> Result<Self, CaptureError> {
        Ok(CaptureHandle)
    }
}
```

DO NOT use WINDIVERT_FLAG_DROP - we want packet sniffing (copy, not drop). SNIFF flag ensures original packets reach MTGO server uninterrupted.
  </action>
  <verify>grep -E "(CaptureHandle|WinDivert::builder|WINDIVERT_LAYER_NETWORK|WinDivertFlags::SNIFF)" src-tauri/src/capture/handle.rs</verify>
  <done>WinDivert handle wrapper created with Arc sharing and typestate builder pattern</done>
</task>

<task type="auto">
  <name>Task 3: Implement handle cleanup on shutdown</name>
  <files>src-tauri/src/capture/handle.rs</files>
  <action>
Add cleanup functionality to src-tauri/src/capture/handle.rs:

```rust
impl Drop for CaptureHandle {
    /// Ensure WinDivert handle is properly closed when dropped
    ///
    /// The WinDivert<Network> type implements Drop, so closing the Arc
    /// when the last reference is dropped automatically closes the WinDivert handle.
    fn drop(&mut self) {
        #[cfg(target_os = "windows")]
        {
            // The inner Arc<WinDivert<Network>> will automatically close
            // when this CaptureHandle is dropped and the Arc refcount reaches zero.
            // No manual cleanup needed - RAII handles it.
        }
    }
}
```

The RAII (Resource Acquisition Is Initialization) pattern ensures the WinDivert handle is closed automatically when CaptureHandle goes out of scope. No manual close() calls needed.

DO NOT manually call WinDivertClose - rely on Drop implementation. This prevents resource leaks even on panic or early return.
  </action>
  <verify>grep -E "(impl Drop|fn drop)" src-tauri/src/capture/handle.rs</verify>
  <done>Drop implementation ensures automatic handle cleanup</done>
</task>

</tasks>

<verification>
- MTGO filter defined for outbound TCP traffic
- WinDivert handle creation with typestate builder pattern
- SNIFF flag configured (copy, don't drop packets)
- RAII cleanup via Drop trait
- Project compiles without errors
</verification>

<success_criteria>
WinDivert handle and filter management module created with MTGO traffic filter, handle creation with typestate pattern, and automatic cleanup on shutdown.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-03-SUMMARY.md`
</output>

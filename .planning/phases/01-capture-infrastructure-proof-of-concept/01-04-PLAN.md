---
phase: 01-capture-infrastructure-proof-of-concept
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src/capture-status.tsx, src/App.tsx, src-tauri/src/ui/commands.rs]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Capture status displays admin privilege status"
    - "Start/Stop capture buttons render correctly"
    - "Status updates propagate from Rust backend"
  artifacts:
    - path: "src/capture-status.tsx"
      provides: "Capture status UI component"
      contains: "CaptureStatus"
    - path: "src-tauri/src/ui/commands.rs"
      provides: "Tauri commands for capture control"
      contains: "start_capture|stop_capture|get_capture_status"
  key_links:
    - from: "src/capture-status.tsx"
      to: "src-tauri/src/ui/commands.rs"
      via: "Tauri invoke API"
      pattern: "invoke\\('(start|stop|get)_capture"
    - from: "src-tauri/src/ui/commands.rs"
      to: "src-tauri/src/capture/admin.rs"
      via: "admin privilege check"
      pattern: "is_running_as_admin"
---

<objective>
Create basic capture status UI with admin privilege display and start/stop capture buttons.

Purpose: Provide user interface for packet capture control, displaying admin status and capture state with real-time updates.
Output: Capture status component with Tauri command integration for control and status queries.
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Prior Plan 01-01: Tauri project initialized with vanilla TypeScript template
# Prior Plan 01-02: Admin privilege check Tauri command created (check_admin_privileges)
# This plan creates the capture status UI and additional Tauri commands
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define capture status types and Tauri commands</name>
  <files>src-tauri/src/ui/commands.rs</files>
  <action>
Update src-tauri/src/ui/commands.rs with capture status types and commands:

```rust
use crate::capture::admin::is_running_as_admin;
use crate::common::error::CaptureError;
use serde::Serialize;
use std::sync::Arc;
use tokio::sync::Mutex;

/// Capture state (managed via Arc<Mutex<>> for thread-safe access)
struct CaptureState {
    is_capturing: bool,
    packet_count: u64,
    bytes_per_second: f64,
    last_packet_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl Default for CaptureState {
    fn default() -> Self {
        Self {
            is_capturing: false,
            packet_count: 0,
            bytes_per_second: 0.0,
            last_packet_time: None,
        }
    }
}

/// Admin privilege check response
#[derive(Serialize, Clone)]
pub struct AdminStatus {
    pub is_admin: bool,
    pub can_capture: bool,
}

/// Capture status response
#[derive(Serialize, Clone)]
pub struct CaptureStatus {
    pub is_running: bool,
    pub packet_count: u64,
    pub bytes_per_second: f64,
    pub last_packet_time: Option<String>, // ISO 8601 formatted
}

/// Check if the application is running with administrator privileges
#[tauri::command]
pub async fn check_admin_privileges() -> Result<AdminStatus, String> {
    match is_running_as_admin() {
        Ok(is_admin) => Ok(AdminStatus {
            is_admin,
            can_capture: is_admin,
        }),
        Err(e) => Err(format!("Failed to check admin privileges: {}", e)),
    }
}

/// Get current capture status
#[tauri::command]
pub async fn get_capture_status(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    let state_guard = state.lock().await;

    Ok(CaptureStatus {
        is_running: state_guard.is_capturing,
        packet_count: state_guard.packet_count,
        bytes_per_second: state_guard.bytes_per_second,
        last_packet_time: state_guard.last_packet_time.map(|dt| dt.to_rfc3339()),
    })
}

/// Start packet capture (placeholder - full implementation in Plan 05)
#[tauri::command]
pub async fn start_capture(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    // Check admin privileges first
    if !is_running_as_admin().map_err(|e| e.to_string())? {
        return Err("Application requires Administrator privileges to capture network traffic. Please restart as Administrator.".to_string());
    }

    // Placeholder: Full capture loop implementation in Plan 05
    // For now, just mark as capturing
    let mut state_guard = state.lock().await;
    state_guard.is_capturing = true;
    state_guard.packet_count = 0;

    Ok(CaptureStatus {
        is_running: true,
        packet_count: 0,
        bytes_per_second: 0.0,
        last_packet_time: None,
    })
}

/// Stop packet capture (placeholder - full implementation in Plan 05)
#[tauri::command]
pub async fn stop_capture(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    // Placeholder: Full shutdown implementation in Plan 05
    let mut state_guard = state.lock().await;
    state_guard.is_capturing = false;

    Ok(CaptureStatus {
        is_running: false,
        packet_count: state_guard.packet_count,
        bytes_per_second: state_guard.bytes_per_second,
        last_packet_time: state_guard.last_packet_time.map(|dt| dt.to_rfc3339()),
    })
}
```

Add chrono dependency for timestamp handling:
```bash
cargo add chrono --features "serde"
```

DO NOT implement full capture loop here - that's Plan 05. This plan creates the command signatures and state management.
  </action>
  <verify>grep -E "(CaptureState|CaptureStatus|start_capture|stop_capture|get_capture_status)" src-tauri/src/ui/commands.rs</verify>
  <done>Capture state types and Tauri commands defined with placeholder implementations</done>
</task>

<task type="auto">
  <name>Task 2: Register commands in Tauri main.rs</name>
  <files>src-tauri/src/main.rs</files>
  <action>
Update src-tauri/src/main.rs to register capture commands and initialize shared state:

```rust
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use crate::ui::commands::{CaptureState, check_admin_privileges, get_capture_status, start_capture, stop_capture};
use std::sync::Arc;
use tokio::sync::Mutex;

mod capture;
mod common;
mod ui;

fn main() {
    // Initialize shared capture state
    let capture_state = Arc::new(Mutex::new(CaptureState::default()));

    tauri::Builder::default()
        .manage(capture_state)
        .invoke_handler(tauri::generate_handler![
            check_admin_privileges,
            get_capture_status,
            start_capture,
            stop_capture
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

DO NOT forget to register all commands in invoke_handler or they won't be available to the frontend.
  </action>
  <verify>grep -E "(invoke_handler|check_admin_privileges|get_capture_status|start_capture|stop_capture)" src-tauri/src/main.rs</verify>
  <done>All capture commands registered in Tauri main function with shared state management</done>
</task>

<task type="auto">
  <name>Task 3: Create capture status UI component</name>
  <files>src/capture-status.tsx</files>
  <action>
Create src/capture-status.tsx component:

```typescript
import { invoke } from '@tauri-apps/api/tauri';
import { useEffect, useState } from 'react';

interface AdminStatus {
  is_admin: boolean;
  can_capture: boolean;
}

interface CaptureStatus {
  is_running: boolean;
  packet_count: number;
  bytes_per_second: number;
  last_packet_time: string | null;
}

export function CaptureStatus() {
  const [adminStatus, setAdminStatus] = useState<AdminStatus | null>(null);
  const [captureStatus, setCaptureStatus] = useState<CaptureStatus | null>(null);

  // Check admin privileges on mount
  useEffect(() => {
    invoke<AdminStatus>('check_admin_privileges')
      .then(setAdminStatus)
      .catch(console.error);
  }, []);

  // Poll capture status every 500ms when running
  useEffect(() => {
    if (!captureStatus?.is_running) return;

    const interval = setInterval(async () => {
      try {
        const status = await invoke<CaptureStatus>('get_capture_status');
        setCaptureStatus(status);
      } catch (error) {
        console.error('Failed to get capture status:', error);
      }
    }, 500);

    return () => clearInterval(interval);
  }, [captureStatus?.is_running]);

  const handleStartCapture = async () => {
    try {
      const status = await invoke<CaptureStatus>('start_capture');
      setCaptureStatus(status);
    } catch (error) {
      alert(`Failed to start capture: ${error}`);
    }
  };

  const handleStopCapture = async () => {
    try {
      const status = await invoke<CaptureStatus>('stop_capture');
      setCaptureStatus(status);
    } catch (error) {
      alert(`Failed to stop capture: ${error}`);
    }
  };

  if (!adminStatus) {
    return <div>Loading admin status...</div>;
  }

  return (
    <div style={{ padding: '20px' }}>
      <h1>MTGO Replay Capture</h1>

      {/* Admin Status Section */}
      <div style={{ marginBottom: '20px', padding: '10px', border: '1px solid #ccc' }}>
        <h2>Privilege Status</h2>
        <p>
          Admin: <strong>{adminStatus.is_admin ? '✓ Yes' : '✗ No'}</strong>
          {!adminStatus.can_capture && (
            <span style={{ color: 'red', marginLeft: '10px' }}>
              (Please restart as Administrator to capture traffic)
            </span>
          )}
        </p>
      </div>

      {/* Capture Controls Section */}
      <div style={{ marginBottom: '20px', padding: '10px', border: '1px solid #ccc' }}>
        <h2>Capture Control</h2>
        <button
          onClick={handleStartCapture}
          disabled={!adminStatus.can_capture || captureStatus?.is_running}
          style={{
            padding: '8px 16px',
            marginRight: '10px',
            opacity: !adminStatus.can_capture ? 0.5 : 1,
          }}
        >
          Start Capture
        </button>
        <button
          onClick={handleStopCapture}
          disabled={!captureStatus?.is_running}
          style={{ padding: '8px 16px' }}
        >
          Stop Capture
        </button>
      </div>

      {/* Capture Status Section */}
      {captureStatus && (
        <div style={{ padding: '10px', border: '1px solid #ccc' }}>
          <h2>Capture Status</h2>
          <p>Status: <strong>{captureStatus.is_running ? 'Running' : 'Stopped'}</strong></p>
          <p>Packets Captured: <strong>{captureStatus.packet_count.toLocaleString()}</strong></p>
          <p>Throughput: <strong>{captureStatus.bytes_per_second.toFixed(2)} bytes/s</strong></p>
          <p>Last Packet: <strong>{captureStatus.last_packet_time || 'N/A'}</strong></p>
        </div>
      )}
    </div>
  );
}
```

DO NOT implement complex styling or animations in this phase - keep the UI simple and functional. The focus is on Tauri integration, not visual polish.
  </action>
  <verify>grep -E "(invoke|useEffect|useState)" src/capture-status.tsx</verify>
  <done>Capture status component created with admin check, start/stop buttons, and real-time status polling</done>
</task>

<task type="auto">
  <name>Task 4: Integrate component into main app</name>
  <files>src/App.tsx</files>
  <action>
Update src/App.tsx to use the CaptureStatus component:

```typescript
import { CaptureStatus } from './capture-status';

function App() {
  return <CaptureStatus />;
}

export default App;
```

If the default template has different file structure, ensure the CaptureStatus component is rendered as the main app content.
  </action>
  <verify>cargo tauri dev (app launches and shows capture status UI)</verify>
  <done>Capture status UI displays in Tauri application window</done>
</task>

</tasks>

<verification>
- Capture state types defined with shared Arc<Mutex<CaptureState>>
- Tauri commands registered (start_capture, stop_capture, get_capture_status)
- Frontend component displays admin status
- Start/Stop capture buttons work
- Status polling updates display every 500ms
- Application compiles and runs
</verification>

<success_criteria>
Capture status UI created with admin privilege display, start/stop capture buttons, and real-time status updates via Tauri commands.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-04-SUMMARY.md`
</output>

---
phase: 01-capture-infrastructure-proof-of-concept
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src-tauri/src/common/error.rs, src-tauri/src/capture/admin.rs, src-tauri/src/capture/mod.rs]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Application can detect if running with administrator privileges"
    - "Application can verify WinDivert driver installation"
    - "Clear error messages shown when privileges or driver are missing"
    - "Error type properly propagates through Tauri commands"
  artifacts:
    - path: "src-tauri/src/common/error.rs"
      provides: "Application error types"
      contains: "CaptureError"
    - path: "src-tauri/src/capture/admin.rs"
      provides: "Administrator privilege and WinDivert driver detection"
      contains: "is_running_as_admin|check_windivert_driver"
    - path: "src-tauri/src/capture/mod.rs"
      provides: "Capture module exports"
      contains: "pub mod admin"
  key_links:
    - from: "src-tauri/src/capture/admin.rs"
      to: "windows::Win32::Security"
      via: "token elevation API"
      pattern: "GetTokenInformation|TOKEN_ELEVATION"
    - from: "src-tauri/src/capture/admin.rs"
      to: "src-tauri/src/common/error.rs"
      via: "error conversion"
      pattern: "CaptureError::"
---

<objective>
Implement administrator privilege detection and WinDivert driver verification to provide clear error messages before attempting WinDivert packet capture.

Purpose: Address Pitfall 2 (Admin Privilege Failure Without Clear Messaging) and verify WinDivert driver installation at startup (not just user_setup).
Output: Admin privilege and driver detection module with structured error types.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-capture-infrastructure-proof-of-concept/01-RESEARCH.md

# Prior Plan 01-01 established project structure with dependencies
# This plan creates the error handling, admin detection, and driver verification modules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create common error types module</name>
  <files>src-tauri/src/common/error.rs, src-tauri/src/common/mod.rs</files>
  <action>
Create src-tauri/src/common/mod.rs:
```rust
pub mod error;
```

Create src-tauri/src/common/error.rs with structured error types using thiserror:

```rust
use thiserror::Error;

/// Capture-related errors
#[derive(Error, Debug)]
pub enum CaptureError {
    #[error("Application requires Administrator privileges to capture network traffic. Please restart the application as Administrator.")]
    RequiresAdminPrivileges,

    #[error("Failed to detect administrator privileges: {0}")]
    PrivilegeDetectionFailed(String),

    #[error("WinDivert driver not found. Please download WinDivert 2.2.2-A from https://reqrypt.org/windivert.html and place WinDivert.dll and WinDivert64.sys in the application directory.")]
    WinDivertDriverNotFound,

    #[error("WinDivert driver installation blocked: WinDivert64.sys may be blocked by antivirus. Please add it to the antivirus allowlist.")]
    DriverBlocked,

    #[error("Failed to initialize WinDivert handle: {0}")]
    WinDivertInitFailed(#[from] windivert::error::Error),

    #[error("Packet capture channel error: {0}")]
    ChannelError(String),

    #[error("Capture loop error: {0}")]
    CaptureLoopError(String),
}

/// Implement Into<String> for Tauri command compatibility
impl From<CaptureError> for String {
    fn from(error: CaptureError) -> Self {
        error.to_string()
    }
}
```

DO NOT use String-only errors - structured errors provide better debugging and user feedback. Include the "Into<String>" implementation for Tauri command compatibility. Note the new WinDivertDriverNotFound error for driver verification.
  </action>
  <verify>grep -E "(CaptureError|RequiresAdminPrivileges|WinDivertDriverNotFound|thiserror::Error)" src-tauri/src/common/error.rs</verify>
  <done>Error type defined with variants for admin, WinDivert driver, channel, and driver blocked errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement administrator privilege and WinDivert driver detection</name>
  <files>src-tauri/src/capture/admin.rs, src-tauri/src/capture/mod.rs</files>
  <action>
Create src-tauri/src/capture/mod.rs:
```rust
pub mod admin;
```

Create src-tauri/src/capture/admin.rs using windows crate security APIs (from RESEARCH.md Pattern 3):

```rust
#[cfg(target_os = "windows")]
use windows::Win32::Security::*;
use windows::Win32::Foundation::HANDLE;
use crate::common::error::CaptureError;
use std::path::PathBuf;

/// Check if the application is running with administrator privileges
///
/// Returns true if the process token has elevated privileges, false otherwise.
///
/// This function uses the Windows security API to check the token elevation status
/// of the current process. This is required before attempting to initialize WinDivert,
/// as WinDivert requires administrator privileges to capture network traffic.
#[cfg(target_os = "windows")]
pub fn is_running_as_admin() -> Result<bool, CaptureError> {
    use std::mem;

    // Get current process token
    let mut handle = HANDLE::default();
    let success = unsafe { OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut handle) };

    if !success.as_bool() {
        return Err(CaptureError::PrivilegeDetectionFailed(
            "Failed to open process token".to_string(),
        ));
    }

    // Check elevation status
    let mut elevation = TOKEN_ELEVATION::default();
    let mut ret_len = 0u32;

    let success = unsafe {
        GetTokenInformation(
            handle,
            TokenElevation,
            Some(&mut elevation as *mut _ as *mut _),
            mem::size_of::<TOKEN_ELEVATION>() as u32,
            &mut ret_len,
        )
    };

    if !success.as_bool() {
        return Err(CaptureError::PrivilegeDetectionFailed(
            "Failed to get token elevation information".to_string(),
        ));
    }

    Ok(elevation.TokenIsElevated.as_bool())
}

/// Verify WinDivert driver installation
///
/// Checks if WinDivert driver files are present in the application directory or system32/drivers.
/// This provides clear error messages at startup instead of cryptic WinDivert initialization failures.
///
/// # Returns
/// Ok(true) if driver files found
/// Err(CaptureError::WinDivertDriverNotFound) if missing
#[cfg(target_os = "windows")]
pub fn check_windivert_driver() -> Result<bool, CaptureError> {
    // Check application directory first
    if let Some(exe_path) = std::env::current_exe().ok() {
        let exe_dir = exe_path.parent().unwrap_or(&exe_path);

        // Check for WinDivert.dll (32-bit) or WinDivert64.dll (64-bit)
        if exe_dir.join("WinDivert64.dll").exists() || exe_dir.join("WinDivert.dll").exists() {
            // Check for corresponding .sys file
            if exe_dir.join("WinDivert64.sys").exists() || exe_dir.join("WinDivert.sys").exists() {
                return Ok(true);
            }
        }
    }

    // Check system32/drivers directory (if installed globally)
    let system32 = std::env::var("SystemRoot")
        .unwrap_or_else(|_| "C:\\Windows".to_string());
    let drivers_dir = PathBuf::from(&system32).join("System32").join("drivers");

    if drivers_dir.join("WinDivert64.sys").exists() || drivers_dir.join("WinDivert.sys").exists() {
        return Ok(true);
    }

    Err(CaptureError::WinDivertDriverNotFound)
}

/// Stub implementations for non-Windows targets (development only)
#[cfg(not(target_os = "windows"))]
pub fn is_running_as_admin() -> Result<bool, CaptureError> {
    // For development on non-Windows systems, return true to allow testing
    Ok(true)
}

#[cfg(not(target_os = "windows"))]
pub fn check_windivert_driver() -> Result<bool, CaptureError> {
    // For development on non-Windows systems, assume driver present
    Ok(true)
}
```

DO NOT skip privilege detection - it must run before any WinDivert initialization. The WinDivert driver check provides clear error messages at startup (not just user_setup). The cfg guards allow development on non-Windows systems.
  </action>
  <verify>grep -E "(is_running_as_admin|check_windivert_driver|GetTokenInformation|TOKEN_ELEVATION)" src-tauri/src/capture/admin.rs</verify>
  <done>Admin privilege detection and WinDivert driver verification implemented with Windows security API calls</done>
</task>

<task type="auto">
  <name>Task 3: Create Tauri command for privilege and driver check</name>
  <files>src-tauri/src/ui/commands.rs, src-tauri/src/ui/mod.rs</files>
  <action>
Create src-tauri/src/ui/mod.rs:
```rust
pub mod commands;
```

Create src-tauri/src/ui/commands.rs with privilege and driver check command:

```rust
use crate::capture::admin::{is_running_as_admin, check_windivert_driver};
use crate::common::error::CaptureError;
use serde::Serialize;

/// Admin privilege check response
#[derive(Serialize, Clone)]
pub struct AdminStatus {
    pub is_admin: bool,
    pub can_capture: bool,
    pub windivert_driver_found: bool,
}

/// Check if the application is running with administrator privileges and WinDivert driver is installed
///
/// This command allows the frontend to display appropriate UI (e.g., UAC shield icon, driver status)
/// and guide users to restart as Administrator or download WinDivert if needed.
#[tauri::command]
pub async fn check_admin_privileges() -> Result<AdminStatus, String> {
    let is_admin = is_running_as_admin().map_err(|e| e.to_string())?;
    let driver_found = check_windivert_driver().map_err(|e| e.to_string())?;

    Ok(AdminStatus {
        is_admin,
        can_capture: is_admin && driver_found,
        windivert_driver_found: driver_found,
    })
}
```

DO NOT include privileged operations in the check command - it only queries status, does not attempt capture. The command now includes WinDivert driver verification status.
  </action>
  <verify>grep -E "(check_admin_privileges|AdminStatus|windivert_driver_found)" src-tauri/src/ui/commands.rs</verify>
  <done>Tauri command created for frontend privilege and driver status queries</done>
</task>

</tasks>

<verification>
- Error types module created with CaptureError enum including WinDivertDriverNotFound
- Admin privilege detection implemented using Windows security APIs
- WinDivert driver verification implemented with file existence checks
- Tauri command exposes privilege and driver status to frontend
- Project compiles without errors
</verification>

<success_criteria>
Administrator privilege detection and WinDivert driver verification module implemented with structured error types and Tauri command for frontend integration.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-02-SUMMARY.md`
</output>

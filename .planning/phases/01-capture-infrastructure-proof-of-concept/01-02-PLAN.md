---
phase: 01-capture-infrastructure-proof-of-concept
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src-tauri/src/common/error.rs, src-tauri/src/capture/admin.rs, src-tauri/src/capture/mod.rs]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Application can detect if running with administrator privileges"
    - "Clear error messages shown when privileges are missing"
    - "Error type properly propagates through Tauri commands"
  artifacts:
    - path: "src-tauri/src/common/error.rs"
      provides: "Application error types"
      contains: "CaptureError"
    - path: "src-tauri/src/capture/admin.rs"
      provides: "Administrator privilege detection"
      contains: "is_running_as_admin"
    - path: "src-tauri/src/capture/mod.rs"
      provides: "Capture module exports"
      contains: "pub mod admin"
  key_links:
    - from: "src-tauri/src/capture/admin.rs"
      to: "windows::Win32::Security"
      via: "token elevation API"
      pattern: "GetTokenInformation|TOKEN_ELEVATION"
    - from: "src-tauri/src/capture/admin.rs"
      to: "src-tauri/src/common/error.rs"
      via: "error conversion"
      pattern: "CaptureError::"
---

<objective>
Implement administrator privilege detection to provide clear error messages before attempting WinDivert packet capture.

Purpose: Address Pitfall 2 (Admin Privilege Failure Without Clear Messaging) by detecting privileges early and showing actionable user guidance.
Output: Admin privilege detection module with structured error types.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-capture-infrastructure-proof-of-concept/01-RESEARCH.md

# Prior Plan 01-01 established project structure with dependencies
# This plan creates the error handling and admin detection modules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create common error types module</name>
  <files>src-tauri/src/common/error.rs, src-tauri/src/common/mod.rs</files>
  <action>
Create src-tauri/src/common/mod.rs:
```rust
pub mod error;
```

Create src-tauri/src/common/error.rs with structured error types using thiserror:

```rust
use thiserror::Error;

/// Capture-related errors
#[derive(Error, Debug)]
pub enum CaptureError {
    #[error("Application requires Administrator privileges to capture network traffic. Please restart the application as Administrator.")]
    RequiresAdminPrivileges,

    #[error("Failed to detect administrator privileges: {0}")]
    PrivilegeDetectionFailed(String),

    #[error("Failed to initialize WinDivert handle: {0}")]
    WinDivertInitFailed(#[from] windivert::error::Error),

    #[error("Packet capture channel error: {0}")]
    ChannelError(String),

    #[error("Capture loop error: {0}")]
    CaptureLoopError(String),

    #[error("Driver installation blocked: WinDivert64.sys may be blocked by antivirus. Please add it to the antivirus allowlist.")]
    DriverBlocked,
}

/// Implement Into<String> for Tauri command compatibility
impl From<CaptureError> for String {
    fn from(error: CaptureError) -> Self {
        error.to_string()
    }
}
```

DO NOT use String-only errors - structured errors provide better debugging and user feedback. Include the "Into<String>" implementation for Tauri command compatibility.
  </action>
  <verify>grep -E "(CaptureError|RequiresAdminPrivileges|thiserror::Error)" src-tauri/src/common/error.rs</verify>
  <done>Error type defined with variants for admin, WinDivert, channel, and driver errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement administrator privilege detection</name>
  <files>src-tauri/src/capture/admin.rs, src-tauri/src/capture/mod.rs</files>
  <action>
Create src-tauri/src/capture/mod.rs:
```rust
pub mod admin;
```

Create src-tauri/src/capture/admin.rs using windows crate security APIs (from RESEARCH.md Pattern 3):

```rust
#[cfg(target_os = "windows")]
use windows::Win32::Security::*;
use windows::Win32::Foundation::HANDLE;
use crate::common::error::CaptureError;

/// Check if the application is running with administrator privileges
///
/// Returns true if the process token has elevated privileges, false otherwise.
///
/// This function uses the Windows security API to check the token elevation status
/// of the current process. This is required before attempting to initialize WinDivert,
/// as WinDivert requires administrator privileges to capture network traffic.
#[cfg(target_os = "windows")]
pub fn is_running_as_admin() -> Result<bool, CaptureError> {
    use std::mem;

    // Get current process token
    let mut handle = HANDLE::default();
    let success = unsafe { OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut handle) };

    if !success.as_bool() {
        return Err(CaptureError::PrivilegeDetectionFailed(
            "Failed to open process token".to_string(),
        ));
    }

    // Check elevation status
    let mut elevation = TOKEN_ELEVATION::default();
    let mut ret_len = 0u32;

    let success = unsafe {
        GetTokenInformation(
            handle,
            TokenElevation,
            Some(&mut elevation as *mut _ as *mut _),
            mem::size_of::<TOKEN_ELEVATION>() as u32,
            &mut ret_len,
        )
    };

    if !success.as_bool() {
        return Err(CaptureError::PrivilegeDetectionFailed(
            "Failed to get token elevation information".to_string(),
        ));
    }

    Ok(elevation.TokenIsElevated.as_bool())
}

/// Stub implementation for non-Windows targets (development only)
#[cfg(not(target_os = "windows"))]
pub fn is_running_as_admin() -> Result<bool, CaptureError> {
    // For development on non-Windows systems, return true to allow testing
    Ok(true)
}
```

DO NOT skip privilege detection - it must run before any WinDivert initialization. The cfg guards allow development on non-Windows systems.
  </action>
  <verify>grep -E "(is_running_as_admin|GetTokenInformation|TOKEN_ELEVATION)" src-tauri/src/capture/admin.rs</verify>
  <done>Admin privilege detection implemented with Windows security API calls</done>
</task>

<task type="auto">
  <name>Task 3: Create Tauri command for privilege check</name>
  <files>src-tauri/src/ui/commands.rs, src-tauri/src/ui/mod.rs</files>
  <action>
Create src-tauri/src/ui/mod.rs:
```rust
pub mod commands;
```

Create src-tauri/src/ui/commands.rs with privilege check command:

```rust
use crate::capture::admin::is_running_as_admin;
use crate::common::error::CaptureError;
use serde::Serialize;

/// Admin privilege check response
#[derive(Serialize, Clone)]
pub struct AdminStatus {
    pub is_admin: bool,
    pub can_capture: bool,
}

/// Check if the application is running with administrator privileges
///
/// This command allows the frontend to display appropriate UI (e.g., UAC shield icon)
/// and guide users to restart as Administrator if needed.
#[tauri::command]
pub async fn check_admin_privileges() -> Result<AdminStatus, String> {
    match is_running_as_admin() {
        Ok(is_admin) => Ok(AdminStatus {
            is_admin,
            can_capture: is_admin,
        }),
        Err(e) => Err(format!("Failed to check admin privileges: {}", e)),
    }
}
```

DO NOT include privileged operations in the check command - it only queries status, does not attempt capture. The command must return a structured type (AdminStatus) not just a boolean, to support future fields.
  </action>
  <verify>grep -E "(check_admin_privileges|AdminStatus)" src-tauri/src/ui/commands.rs</verify>
  <done>Tauri command created for frontend privilege status queries</done>
</task>

</tasks>

<verification>
- Error types module created with CaptureError enum
- Admin privilege detection implemented using Windows security APIs
- Tauri command exposes privilege status to frontend
- Project compiles without errors
</verification>

<success_criteria>
Administrator privilege detection module implemented with structured error types and Tauri command for frontend integration.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-02-SUMMARY.md`
</output>

---
phase: 01-capture-infrastructure-proof-of-concept
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified: [src-tauri/src/capture/loop.rs, src-tauri/src/ui/commands.rs, src-tauri/src/capture/mod.rs]
autonomous: false
user_setup:
  - service: WinDivert
    why: "Required for packet capture - must be installed before testing"
    dashboard_config:
      - task: "Verify WinDivert driver is installed"
        location: "Run 'sc query WinDivert1.0' in elevated Command Prompt"
      - task: "Test with MTGO client running"
        location: "Start MTGO client and log in to generate network traffic"

must_haves:
  truths:
    - "Packet capture loop receives packets from WinDivert handle"
    - "Bounded MPSC channel provides backpressure (PERF-004)"
    - "Capture status updates in real-time (packet count, throughput)"
    - "Capture stops gracefully on stop_capture command"
    - "Actual MTGO traffic visible in capture (requires manual verification with MTGO client)"
  artifacts:
    - path: "src-tauri/src/capture/loop.rs"
      provides: "Async packet capture loop with bounded channels"
      contains: "capture_loop"
    - path: "src-tauri/src/ui/commands.rs"
      provides: "Tauri commands with full capture loop integration"
      contains: "start_capture|stop_capture"
  key_links:
    - from: "src-tauri/src/capture/loop.rs"
      to: "src-tauri/src/capture/handle.rs"
      via: "WinDivert handle reference"
      pattern: "Arc<WinDivert<Network>>"
    - from: "src-tauri/src/capture/loop.rs"
      to: "tokio::sync::mpsc"
      via: "bounded channel for backpressure"
      pattern: "mpsc::channel\\("
    - from: "src-tauri/src/capture/loop.rs"
      to: "src-tauri/src/ui/commands.rs"
      via: "capture task management and shutdown signal"
      pattern: "AbortHandle|capture_task"
---

<objective>
Implement async packet capture loop with bounded MPSC channels for backpressure (PERF-004) and real-time status updates.

Purpose: Create the core packet capture infrastructure following RESEARCH.md Pattern 2 (Bounded MPSC Channels), avoiding Pitfall 3 (Packet Burst Overflow Without Backpressure).
Output: Working packet capture system with real-time status monitoring and graceful shutdown.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-capture-infrastructure-proof-of-concept/01-RESEARCH.md

# Prior Plan 01-03: WinDivert handle and filter module created
# Prior Plan 01-04: Capture status UI and Tauri command placeholders created
# This plan implements the full capture loop with bounded channels and integrates with UI
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create capture loop module with bounded channels</name>
  <files>src-tauri/src/capture/loop.rs, src-tauri/src/capture/mod.rs</files>
  <action>
Update src-tauri/src/capture/mod.rs:
```rust
pub mod admin;
pub mod handle;
pub mod filter;
pub mod loop_;
```

Create src-tauri/src/capture/loop.rs with async capture loop (from RESEARCH.md Pattern 2):

```rust
#[cfg(target_os = "windows")]
use crate::capture::handle::CaptureHandle;
#[cfg(target_os = "windows")]
use windivert::{layer::Network, WinDivert};
use crate::common::error::CaptureError;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Channel capacity for packet capture (PERF-004)
///
/// Per RESEARCH.md Open Question 2, optimal capacity is unknown.
/// Starting with 1000 packets based on typical burst patterns.
/// Will adjust based on proof-of-concept metrics.
const CHANNEL_CAPACITY: usize = 1000;

/// Packet data with metadata
#[derive(Debug, Clone)]
#[cfg(target_os = "windows")]
pub struct CapturedPacket {
    pub data: Vec<u8>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub length: usize,
}

/// Capture loop statistics
#[derive(Debug, Clone, Default)]
pub struct CaptureStats {
    pub packet_count: u64,
    pub bytes_captured: u64,
    pub last_packet_time: Option<chrono::DateTime<chrono::Utc>>,
}

/// Run the packet capture loop
///
/// This function creates a bounded MPSC channel and spawns an async task that:
/// 1. Receives packets from WinDivert handle
/// 2. Sends packets to the channel (with backpressure)
/// 3. Updates capture statistics
/// 4. Responds to shutdown signals
///
/// The channel provides backpressure (PERF-004): if the consumer (protocol decoder,
/// implemented in future phases) is too slow, the channel fills up and the producer
/// blocks on send(), preventing unbounded memory growth.
///
/// # Arguments
/// * `handle` - WinDivert handle for packet capture
/// * `shutdown_tx` - Optional shutdown signal sender (None = manual shutdown)
///
/// # Returns
/// Tuple of (packet receiver, shutdown handle) for control integration
#[cfg(target_os = "windows")]
pub fn capture_loop(
    handle: Arc<WinDivert<Network>>,
    shutdown_tx: Option<mpsc::Sender<()>>,
) -> (mpsc::Receiver<CapturedPacket>, tokio::task::AbortHandle) {
    // Create bounded channel for packet flow (PERF-004)
    let (packet_tx, packet_rx) = mpsc::channel::<CapturedPacket>(CHANNEL_CAPACITY);

    // Spawn capture task
    let task = tokio::spawn(async move {
        info!("Packet capture loop started (channel capacity: {})", CHANNEL_CAPACITY);

        let mut stats = CaptureStats::default();
        let mut shutdown_rx = shutdown_tx.map(|tx| tx.subscribe());
        let mut last_throughput_check = Instant::now();
        let mut bytes_at_last_check = 0u64;

        loop {
            // Check for shutdown signal
            if let Some(rx) = &mut shutdown_rx {
                if rx.try_recv().is_ok() {
                    info!("Shutdown signal received, stopping capture");
                    break;
                }
            }

            // Receive packet from WinDivert (with timeout for shutdown check)
            let packet_result = tokio::time::timeout(
                Duration::from_millis(100),
                handle.recv(),
            ).await;

            match packet_result {
                Ok(Ok((packet, address))) => {
                    // Capture successful
                    let timestamp = chrono::Utc::now();
                    let length = packet.len();

                    // Update statistics
                    stats.packet_count += 1;
                    stats.bytes_captured += length as u64;
                    stats.last_packet_time = Some(timestamp);

                    // Create captured packet structure
                    let captured = CapturedPacket {
                        data: packet.to_vec(),
                        timestamp,
                        length,
                    };

                    // Send to channel with backpressure
                    match packet_tx.send(captured).await {
                        Ok(_) => {
                            debug!("Packet {} captured: {} bytes", stats.packet_count, length);
                        }
                        Err(_) => {
                            // Channel closed, stop capture
                            warn!("Packet channel closed, stopping capture");
                            break;
                        }
                    }

                    // Calculate and log throughput every second
                    let elapsed = last_throughput_check.elapsed();
                    if elapsed >= Duration::from_secs(1) {
                        let bytes_delta = stats.bytes_captured - bytes_at_last_check;
                        let throughput = bytes_delta as f64 / elapsed.as_secs_f64();

                        if stats.packet_count % 100 == 0 {
                            info!(
                                "Captured {} packets, {:.2} bytes/s",
                                stats.packet_count, throughput
                            );
                        }

                        bytes_at_last_check = stats.bytes_captured;
                        last_throughput_check = Instant::now();
                    }
                }
                Ok(Err(e)) => {
                    error!("Error receiving packet: {}", e);
                    break;
                }
                Err(_) => {
                    // Timeout - continue loop (allows shutdown check)
                    continue;
                }
            }
        }

        info!("Packet capture loop stopped. Total: {} packets, {} bytes",
              stats.packet_count, stats.bytes_captured);
    });

    // Return receiver and abort handle for control
    let abort_handle = task.abort_handle();

    // Note: For now, we're NOT returning the packet receiver to the protocol decoder
    // because Phase 1 is just capture infrastructure. In Phase 2, we'll connect
    // the receiver to the protocol decoder.

    (packet_rx, abort_handle)
}

/// Stub implementation for non-Windows targets (development only)
#[cfg(not(target_os = "windows"))]
pub struct CapturedPacket;

#[cfg(not(target_os = "windows"))]
pub struct CaptureStats;

#[cfg(not(target_os = "windows"))]
pub fn capture_loop(
    _handle: (),
    _shutdown_tx: Option<tokio::sync::mpsc::Sender<()>>,
) -> (tokio::sync::mpsc::Receiver<CapturedPacket>, tokio::task::AbortHandle) {
    let (tx, rx) = tokio::sync::mpsc::channel(1);
    let handle = tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;
        drop(tx);
    });
    (rx, handle.abort_handle())
}
```

DO NOT use unbounded channels - they violate PERF-004 (bounded queues). The 1000-packet capacity provides backpressure while handling typical burst patterns.
  </action>
  <verify>grep -E "(capture_loop|CHANNEL_CAPACITY|mpsc::channel|RecvTimeout)" src-tauri/src/capture/loop.rs</verify>
  <done>Capture loop module created with bounded MPSC channel and backpressure handling</done>
</task>

<task type="auto">
  <name>Task 2: Integrate capture loop with Tauri commands</name>
  <files>src-tauri/src/ui/commands.rs</files>
  <action>
Update src-tauri/src/ui/commands.rs with full capture loop integration:

```rust
use crate::capture::admin::is_running_as_admin;
use crate::capture::handle::CaptureHandle;
use crate::capture::loop_::{capture_loop, CaptureStats};
use crate::common::error::CaptureError;
use serde::Serialize;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};

/// Capture task handle for shutdown control
struct CaptureTask {
    abort_handle: tokio::task::AbortHandle,
    shutdown_tx: mpsc::Sender<()>,
}

impl CaptureTask {
    fn shutdown(&self) {
        self.abort_handle.abort();
    }
}

/// Capture state (managed via Arc<Mutex<>> for thread-safe access)
pub struct CaptureState {
    is_capturing: bool,
    packet_count: u64,
    bytes_per_second: f64,
    last_packet_time: Option<chrono::DateTime<chrono::Utc>>,
    capture_task: Option<CaptureTask>,
}

impl Default for CaptureState {
    fn default() -> Self {
        Self {
            is_capturing: false,
            packet_count: 0,
            bytes_per_second: 0.0,
            last_packet_time: None,
            capture_task: None,
        }
    }
}

/// Admin privilege check response
#[derive(Serialize, Clone)]
pub struct AdminStatus {
    pub is_admin: bool,
    pub can_capture: bool,
}

/// Capture status response
#[derive(Serialize, Clone)]
pub struct CaptureStatus {
    pub is_running: bool,
    pub packet_count: u64,
    pub bytes_per_second: f64,
    pub last_packet_time: Option<String>, // ISO 8601 formatted
}

/// Check if the application is running with administrator privileges
#[tauri::command]
pub async fn check_admin_privileges() -> Result<AdminStatus, String> {
    match is_running_as_admin() {
        Ok(is_admin) => Ok(AdminStatus {
            is_admin,
            can_capture: is_admin,
        }),
        Err(e) => Err(format!("Failed to check admin privileges: {}", e)),
    }
}

/// Get current capture status
#[tauri::command]
pub async fn get_capture_status(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    let state_guard = state.lock().await;

    Ok(CaptureStatus {
        is_running: state_guard.is_capturing,
        packet_count: state_guard.packet_count,
        bytes_per_second: state_guard.bytes_per_second,
        last_packet_time: state_guard.last_packet_time.map(|dt| dt.to_rfc3339()),
    })
}

/// Start packet capture
#[tauri::command]
pub async fn start_capture(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    // Check if already capturing
    {
        let state_guard = state.lock().await;
        if state_guard.is_capturing {
            return Err("Capture is already running".to_string());
        }
    }

    // Check admin privileges first
    if !is_running_as_admin().map_err(|e| e.to_string())? {
        return Err("Application requires Administrator privileges to capture network traffic. Please restart as Administrator.".to_string());
    }

    // Create WinDivert handle
    let handle = CaptureHandle::new()
        .map_err(|e| format!("Failed to initialize WinDivert: {}", e))?;

    // Create shutdown channel
    let (shutdown_tx, _shutdown_rx) = mpsc::channel::<_>(1);

    // Start capture loop
    let (_packet_rx, abort_handle) = capture_loop(
        handle.clone_handle(),
        Some(shutdown_tx.clone()),
    );

    // Update state
    let mut state_guard = state.lock().await;
    state_guard.is_capturing = true;
    state_guard.packet_count = 0;
    state_guard.bytes_per_second = 0.0;
    state_guard.last_packet_time = None;
    state_guard.capture_task = Some(CaptureTask {
        abort_handle,
        shutdown_tx,
    });

    Ok(CaptureStatus {
        is_running: true,
        packet_count: 0,
        bytes_per_second: 0.0,
        last_packet_time: None,
    })
}

/// Stop packet capture
#[tauri::command]
pub async fn stop_capture(
    state: tauri::State<'_, Arc<Mutex<CaptureState>>>,
) -> Result<CaptureStatus, String> {
    // Get capture task and shut down
    let capture_task_opt = {
        let mut state_guard = state.lock().await;
        if !state_guard.is_capturing {
            return Err("Capture is not running".to_string());
        }
        state_guard.is_capturing = false;
        state_guard.capture_task.take()
    };

    if let Some(capture_task) = capture_task_opt {
        // Send shutdown signal
        let _ = capture_task.shutdown_tx.send(()).await;

        // Give task time to shutdown gracefully
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

        // Abort if still running
        capture_task.shutdown();
    }

    let state_guard = state.lock().await;
    Ok(CaptureStatus {
        is_running: false,
        packet_count: state_guard.packet_count,
        bytes_per_second: state_guard.bytes_per_second,
        last_packet_time: state_guard.last_packet_time.map(|dt| dt.to_rfc3339()),
    })
}
```

DO NOT spawn multiple capture tasks - check `is_capturing` state before starting. Ensure shutdown sends signal and aborts task.
  </action>
  <verify>grep -E "(CaptureTask|CaptureState|start_capture|stop_capture)" src-tauri/src/ui/commands.rs</verify>
  <done>Tauri commands integrated with capture loop, task management, and graceful shutdown</done>
</task>

<task type="auto">
  <name>Task 3: Update main.rs with loop module</name>
  <files>src-tauri/src/main.rs</files>
  <action>
Update src-tauri/src/main.rs to include loop module:

```rust
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use crate::ui::commands::{CaptureState, check_admin_privileges, get_capture_status, start_capture, stop_capture};
use std::sync::Arc;
use tokio::sync::Mutex;

mod capture;
mod common;
mod ui;

fn main() {
    // Initialize shared capture state
    let capture_state = Arc::new(Mutex::new(CaptureState::default()));

    tauri::Builder::default()
        .manage(capture_state)
        .invoke_handler(tauri::generate_handler![
            check_admin_privileges,
            get_capture_status,
            start_capture,
            stop_capture
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

The mod capture; already includes loop.rs via the mod.rs file.
  </action>
  <verify>cargo check (compiles successfully)</verify>
  <done>Main.rs updated to include all capture modules</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete packet capture system with WinDivert integration, bounded channels for backpressure, admin privilege detection, and Tauri UI for control and status monitoring.</what-built>
  <how-to-verify>
1. **Verify WinDivert Installation:**
   - Open Command Prompt as Administrator
   - Run: `sc query WinDivert1.0`
   - Verify it shows "RUNNING" or "STOPPED" (not "does not exist")
   - If driver missing, download WinDivert 2.2.2-A from https://reqrypt.org/windivert.html
   - Place WinDivert.dll and WinDivert64.sys in the application directory

2. **Run Application as Administrator:**
   - Right-click mtgo-replay.exe or use `cargo tauri dev`
   - Run as Administrator (required for WinDivert)
   - Verify UI shows "Admin: ✓ Yes"

3. **Test Capture Without MTGO:**
   - Click "Start Capture" button
   - Verify UI shows "Status: Running"
   - Verify "Packets Captured" increases over time (browsing web generates traffic)
   - Click "Stop Capture"
   - Verify "Status: Stopped" and packet count stabilizes

4. **Test With MTGO Client (CRITICAL for Phase 1 validation):**
   - Start MTGO client and log in
   - Start packet capture in mtgo-replay application
   - Play a game or interact with MTGO (open deck editor, join lobby)
   - Monitor capture statistics in UI
   - Verify packet count increases significantly during MTGO activity
   - Stop capture

5. **Verify Logs:**
   - Check terminal/console output for "Packet capture loop started"
   - Verify log shows "Captured N packets, X bytes/s" (every 100 packets)
   - Verify no "ERROR" messages related to WinDivert or channel errors

6. **Test Error Handling:**
   - Close application and restart WITHOUT Administrator privileges
   - Verify UI shows "Admin: ✗ No" with red warning
   - Click "Start Capture" - verify error message: "Application requires Administrator privileges"
   - Restart as Administrator and verify capture works again
  </how-to-verify>
  <resume-signal>Type "approved" if capture works correctly, or describe issues with packet reception, WinDivert errors, or UI problems.</resume-signal>
</task>

</tasks>

<verification>
- Capture loop implemented with bounded MPSC channels (1000 packet capacity)
- WinDivert handle integration with async packet reception
- Tauri commands fully integrated with capture task management
- Graceful shutdown via shutdown signal + abort handle
- Real-time status updates (packet count, throughput, timestamp)
- Project compiles without errors
</verification>

<success_criteria>
Working packet capture system with WinDivert integration, bounded channels for backpressure, admin privilege detection, and Tauri UI for control and monitoring. Capture verified with actual network traffic.
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-infrastructure-proof-of-concept/01-05-SUMMARY.md`
</output>
